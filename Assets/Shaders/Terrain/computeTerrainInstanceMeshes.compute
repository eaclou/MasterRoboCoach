// This shader computes the positions,rotations, scales etc. of instanced pebbles, rocks, and cliffs, based on terrain height and other map data:
#include "Assets/Shaders/Inc/NoiseShared.cginc"


struct TransformData {
    float4 worldPos;
    float3 scale;
    float4 rotation;
};

float4 _QuadBounds;
float4 _GlobalBounds;
int _NumPebblesSide;
int _NumRocksSide;

RWStructuredBuffer<TransformData> instancedPebblesCBuffer;
RWStructuredBuffer<TransformData> instancedRocksCBuffer;
RWStructuredBuffer<float4x4> instancedRocksInvMatrixCBuffer;
Texture2D heightTexture0;
Texture2D heightTexture1;
Texture2D heightTexture2;
Texture2D heightTexture3;

SamplerState _LinearClamp;
SamplerState _PointClamp;

float rand(in float2 uv)
{
	float2 noise = (frac(sin(dot(uv ,float2(12.9898,78.233)*2.0)) * 43758.5453));
	return abs(noise.x + noise.y) * 0.5;
}

#pragma kernel CSInitializeInstancePebblesData
[numthreads(32,32,1)]
void CSInitializeInstancePebblesData (uint3 id : SV_DispatchThreadID)
{
	float baseScale = 0.02;
	float gridSize = 20;

	// Figure out x,z coordinates
	float numPebblesSide = (float)_NumPebblesSide;
	float2 horizontalPos = float2((float)id.x - (numPebblesSide / 2), (float)id.y - (numPebblesSide / 2)) * (gridSize / numPebblesSide);

	// RandomOffset:
	float maxOffsetValue = (gridSize / numPebblesSide) / 2 * 8;
	float3 noiseSample = Value2D(horizontalPos, 2.6);
	float2 posOffset = noiseSample.yz * maxOffsetValue + rand(horizontalPos);
	horizontalPos += posOffset;

	//float xRange = _QuadBounds.y - _QuadBounds.x;
	//float zRange = _QuadBounds.w - _QuadBounds.z;
	//float xPart = float(id.x) / (float)(resolutionX - 1);
	//float zPart = float(id.z) / (float)(resolutionZ - 1);
	//float x = xPart * xRange + _QuadBounds.x;
	//float z = zPart * zRange + _QuadBounds.z;  // worldCoords

	float2 globalRange = float2(_GlobalBounds.y - _GlobalBounds.x, _GlobalBounds.w - _GlobalBounds.z);
	float2 uv0 = horizontalPos / 680 * 0.5 + 0.5;
	float2 uv1 = uv0 * 2 - 0.5;
	float2 uv2 = uv1 * 2 - 0.5;
	float2 uv3 = uv2 * 2 - 0.5;

	

	// look up height texture
	float4 textureSample3 =  heightTexture3.SampleLevel(_LinearClamp, uv3, 0);

	// set Y pos to match terrain (rock+sediment)

	//Random Rotation
	float qx = rand(horizontalPos);
	float qy = rand(horizontalPos + 10.1);
	float qz = rand(horizontalPos + 23.97);
	float qw = rand(horizontalPos + 49.66234);
	float4 randQuaternion = normalize(float4(qx,qy,qz,qw) * 2 - 1);

	//RandomScale
	float sx = rand(horizontalPos - 197.8765);
	float sy = rand(horizontalPos - 7497.238);
	float sz = rand(horizontalPos - 1200.321);
	float3 randScale = ((float3(sx, sy, sz) * 2) * baseScale + float3(baseScale,baseScale,baseScale)) * saturate(textureSample3).y;

	int index = id.x * _NumPebblesSide + id.y;
	instancedPebblesCBuffer[index].worldPos = float4(horizontalPos.x, textureSample3.x + textureSample3.y,horizontalPos.y, 1);
	instancedPebblesCBuffer[index].scale = randScale;
	instancedPebblesCBuffer[index].rotation = randQuaternion;
	
}

float4x4 inverse(float4x4 input)
{
#define minor(a,b,c) determinant(float3x3(input.a, input.b, input.c))
 
    float4x4 cofactors = float4x4(
        minor(_22_23_24, _32_33_34, _42_43_44),
        -minor(_21_23_24, _31_33_34, _41_43_44),
        minor(_21_22_24, _31_32_34, _41_42_44),
        -minor(_21_22_23, _31_32_33, _41_42_43),
 
        -minor(_12_13_14, _32_33_34, _42_43_44),
        minor(_11_13_14, _31_33_34, _41_43_44),
        -minor(_11_12_14, _31_32_34, _41_42_44),
        minor(_11_12_13, _31_32_33, _41_42_43),
 
        minor(_12_13_14, _22_23_24, _42_43_44),
        -minor(_11_13_14, _21_23_24, _41_43_44),
        minor(_11_12_14, _21_22_24, _41_42_44),
        -minor(_11_12_13, _21_22_23, _41_42_43),
 
        -minor(_12_13_14, _22_23_24, _32_33_34),
        minor(_11_13_14, _21_23_24, _31_33_34),
        -minor(_11_12_14, _21_22_24, _31_32_34),
        minor(_11_12_13, _21_22_23, _31_32_33)
        );
#undef minor
    return transpose(cofactors) / determinant(input);
}

#pragma kernel CSInitializeInstanceRocksData
[numthreads(32,32,1)]
void CSInitializeInstanceRocksData (uint3 id : SV_DispatchThreadID)
{
	float baseScale = 0.5;
	float gridSize = 1024;

	// Figure out x,z coordinates
	float numRocksSide = (float)_NumRocksSide;
	float2 horizontalPos = float2((float)id.x - (numRocksSide / 2), (float)id.y - (numRocksSide / 2)) * (gridSize / numRocksSide);

	// RandomOffset:
	float maxOffsetValue = (gridSize / numRocksSide) / 2 * 8;
	float3 noiseSample = Value2D(horizontalPos, 2.6);
	float2 posOffset = noiseSample.yz * maxOffsetValue + rand(horizontalPos);
	horizontalPos += posOffset;
	
	float taxiDistance = max(abs(horizontalPos.x / 680), abs(horizontalPos.y / 680)) + 0.000001;  // 0 - 1  // can't equal 0
	float log = max(0, abs(log2(1.0 / taxiDistance)) - 1.0);  // hacky magic to figure out how many subdivisions at this location
	float2 globalRange = float2(_GlobalBounds.y - _GlobalBounds.x, _GlobalBounds.w - _GlobalBounds.z);
	float2 uv0 = horizontalPos / 680 * 0.5 + 0.5;
	float2 uv1 = uv0 * 2 - 0.5;
	float2 uv2 = uv1 * 2 - 0.5;
	float2 uv3 = uv2 * 2 - 0.5;
	// look up height texture
	// Better way to do this with TextureArrays, 3D RenderTexture or something else so I can use an index, but fuck it for now:
	float4 textureSample0 =  heightTexture0.SampleLevel(_LinearClamp, uv0, 0);
	float4 textureSample1 =  heightTexture1.SampleLevel(_LinearClamp, uv1, 0);
	float4 textureSample2 =  heightTexture2.SampleLevel(_LinearClamp, uv2, 0);
	float4 textureSample3 =  heightTexture3.SampleLevel(_LinearClamp, uv3, 0);
	float weight0 = (1.0 - saturate(log - 0));
	float weight1 = frac(1.0 - saturate(log - 1)) + frac(saturate(log - 0));
	float weight2 = frac(1.0 - saturate(log - 2)) + frac(saturate(log - 1));
	float weight3 = saturate(log - 2);

	float4 sampleValue = textureSample0 * weight0 + textureSample1 * weight1 + textureSample2 * weight2 + textureSample3 * weight3;

	//float gradX = ddx(textureSample0.x);
	//float gradY = ddy(textureSample0.x); // (z)
	//float gradMag = length(float2(gradX, gradY));

	// set Y pos to match terrain (rock+sediment)

	//Random Rotation
	float rx = rand(horizontalPos);
	float ry = rand(horizontalPos + 10.1);
	float rz = rand(horizontalPos + 23.97);
	float rw = rand(horizontalPos + 49.66234);
	float4 randQuaternion = normalize(float4(rx,ry,rz,rw) * 2 - 1);

	//RandomScale
	float sx = rand(horizontalPos - 197.8765);
	float sy = rand(horizontalPos - 7497.238);
	float sz = rand(horizontalPos - 1200.321);
	float3 randScale = (((float3(sx, sy, sz) * 3) * baseScale + float3(baseScale,baseScale,baseScale))); // * gradMag;

	int index = id.x * _NumRocksSide + id.y;
	instancedRocksCBuffer[index].worldPos = float4(horizontalPos.x, sampleValue.x, horizontalPos.y, 1);
	instancedRocksCBuffer[index].scale = randScale;
	instancedRocksCBuffer[index].rotation = randQuaternion;
		
	// INVERSE MATRIX::::
	float4x4 mObjectToWorld;
	mObjectToWorld._11_21_31_41 = float4(sx, 0, 0, 0);
    mObjectToWorld._12_22_32_42 = float4(0, sy, 0, 0);
    mObjectToWorld._13_23_33_43 = float4(0, 0, sz, 0);
    mObjectToWorld._14_24_34_44 = float4(horizontalPos.x, sampleValue.x, horizontalPos.y, 1);
	// rotation
    float4x4 rotationMatrix = float4x4(  // XYZ:
        cos(ry)*cos(rz), -cos(ry)*sin(rz), sin(ry), 0,
        cos(rx)*sin(rz)+sin(rx)*sin(ry)*cos(rz), cos(rx)*cos(rz)-sin(rx)*sin(ry)*sin(rz), -sin(rx)*cos(ry), 0,
        sin(rx)*sin(rz)-cos(rx)*sin(ry)*cos(rz), sin(rx)*cos(rz)+cos(rx)*sin(ry)*sin(rz), cos(rx)*cos(ry), 0,
        0, 0, 0, 1);
	//float4x4 rotationMatrix = float4x4(  // ZXY:
    //    cos(rz)*cos(ry)-sin(rz)*cos(rx)*cos(ry)-sin(rz)*sin(rx)*sin(ry), -sin(rz)*cos(rx), cos(rz)*sin(ry)-sin(rz)*cos(rx)*sin(ry)+sin(rz)*sin(rx)*cos(ry), 0,
    //    sin(rz)*cos(ry)-cos(rx)*sin(ry), cos(rz)*cos(rx), sin(rz)*sin(ry)-cos(rz)*sin(rx)*cos(ry), 0,
    //    -cos(rx)*sin(ry), sin(rx), cos(rx)*cos(ry), 0,
    //    0, 0, 0, 1);
	mObjectToWorld = mul(mObjectToWorld, rotationMatrix);

	float4x4 mWorldToObject = inverse(mObjectToWorld);
	instancedRocksInvMatrixCBuffer[index] = mWorldToObject;
}
