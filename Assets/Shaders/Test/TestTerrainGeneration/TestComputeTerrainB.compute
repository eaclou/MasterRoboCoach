#include "Assets/Shaders/Inc/NoiseShared.cginc"

struct VertexData {
    float3 worldPos;
	float3 normal;
    float2 uv;
    float3 color;
};
struct GenomeNoiseOctaveData {
    float amplitude;
    float frequency;
    float3 offset;
};
struct TriangleIndexData {
    int v1;
    int v2;
    int v3;
};

int texturePixelsX = 8;
int texturePixelsY = 8;
int meshResolutionX = 8;
int meshResolutionZ = 8;
float xStart = 0;
float xEnd = 8;
float zStart = 0;
float zEnd = 8;


StructuredBuffer<GenomeNoiseOctaveData> terrainGenomeCBuffer;
RWStructuredBuffer<VertexData> terrainVertexDataCBuffer;
RWStructuredBuffer<TriangleIndexData> terrainTriangleIndexDataCBuffer;

RWTexture2D<float4> mainHeightTexture;
Texture2D<float4> mainHeightTextureRead;
SamplerState _LinearClamp;


// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSInitializeTextureHeightData
[numthreads(1,1,1)]
void CSInitializeTextureHeightData (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!
	
	uint elements;
	uint stride;
	terrainGenomeCBuffer.GetDimensions(elements, stride);	
	float noiseOctaveCount = (float)elements;

	//int index = id.x * texturePixelsX + id.y;

	float xRange = xEnd - xStart;
	float zRange = zEnd - zStart;
	float xPart = float(id.x) / (float)texturePixelsX;
	float zPart = float(id.y) / (float)texturePixelsY;
	float x = xPart * xRange + xStart;
	float z = zPart * zRange + zStart;

	float accumulatedAltitude = 0;
	float maxValue = 0;

	// NOISE!!!!
	for(int i = 0; i < 4; i++) {
		if(i < noiseOctaveCount) {			
			float3 noiseSample = Value2D(float2(x,z) + terrainGenomeCBuffer[i].offset.xz, terrainGenomeCBuffer[i].frequency);
			accumulatedAltitude += noiseSample.x * terrainGenomeCBuffer[i].amplitude;
			maxValue += terrainGenomeCBuffer[i].amplitude;
		}	
	}
	
	//float2 uv = float2(xPart,zPart);
	float colorValue = accumulatedAltitude;
	mainHeightTexture[float2(id.x,id.y)] = float4(colorValue,colorValue,0.25,1);
}

// GENERATE VERTEX DATA:::::
#pragma kernel CSTest
[numthreads(1,1,1)]
void CSTest (uint3 id : SV_DispatchThreadID)
{
	//float h, w;
	//tex.GetDimensions(w, h);

	float xRange = xEnd - xStart;
	float zRange = zEnd - zStart;
	float xPart = float(id.x) / (float)meshResolutionX;
	float zPart = float(id.y) / (float)meshResolutionZ;
	float x = xPart * xRange + xStart;
	float z = zPart * zRange + zStart;

	int cBufferIndex = id.x * meshResolutionZ + id.y;
	float2 textureIndex = float2(0,0); //float2(round(xPart * (float)texturePixelsX), round(zPart * (float)texturePixelsY));

	//float4 texLoad = mainHeightTexture.Load(uint3(id.x, id.y,0));
	float4 readRenderTex = mainHeightTextureRead.SampleLevel(_LinearClamp, float2(xPart, zPart), 0);
	
	float height = readRenderTex.x + readRenderTex.b * 0.2;   //0.5;

	VertexData vertexData;
	vertexData.worldPos = float3(x, height, z);
	vertexData.normal = float3(0,1,0);
	vertexData.uv = float2(xPart, zPart);
	vertexData.color = float3(readRenderTex.g * 0.5 + 0.5,readRenderTex.g * 0.5 + 0.5,readRenderTex.g * 0.5 + 0.5);

	//float4 textureValue = mainHeightTexture.Sample(_LinearClamp, float2(xPart, zPart));
	

	terrainVertexDataCBuffer[cBufferIndex] = vertexData;

}


#pragma kernel CSGenerateTriangleIndices

[numthreads(1,1,1)]
void CSGenerateTriangleIndices (uint3 id : SV_DispatchThreadID)
{
	TriangleIndexData triangleIndexData0;
	TriangleIndexData triangleIndexData1;

	int index0 = (id.x * (meshResolutionZ - 1) + id.z) * 2;
	int index1 = index0 + 1;

	int v00 = id.x * meshResolutionZ + id.z;
	int v10 = (id.x + 1) * meshResolutionZ + id.z;
	int v01 = id.x * meshResolutionZ + (id.z + 1);
	int v11 = (id.x + 1) * meshResolutionZ + (id.z + 1);

	triangleIndexData0.v1 = v00;
	triangleIndexData0.v2 = v01;
	triangleIndexData0.v3 = v11;

	triangleIndexData1.v1 = v00;
	triangleIndexData1.v2 = v11;
	triangleIndexData1.v3 = v10;

	terrainTriangleIndexDataCBuffer[index0] = triangleIndexData0;
	terrainTriangleIndexDataCBuffer[index1] = triangleIndexData1;
}
